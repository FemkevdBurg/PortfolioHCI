<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Portfoliowebsite HCI</title>
    <link type="text/css" href="styles/style.css" rel="stylesheet" />
    <link type="text/css" href="styles/styleWorkshops.css" rel="stylesheet" />
  </head>
  <body>

    <header>

          <a href="index.html"><img src="images/logo.png" alt="logo" id="logo" onclick=""/></a>

        <section class="grid-container menu">

          <div class="menutoggle">
            <p>Menu</p>
            <a id="nav-toggle" href="#"><span></span></a>
          </div>

          <div>
          <nav id="menu" class="inactive">
            <ul>
              <li><a href="index.html">Home</a></li>
              <li><a href="topics.html">Topics</a></li>
              <li><a href="workshops.html" id="active">Workshops</a></li>
              <li><a href="excursion.html">Excursion</a></li>
              <li><a href="labWeeks.html">Lab Weeks</a></li>
            </ul>
          </nav>
        </div>

        </section>

    </header>

    <div id="top">
      <a href="workshops.html"><i class="arrow left"></i></a>
      <h2>VR Environments.</h2>
    </div>

    <div id="uitlegArduino">
      <div id="tekstUitleg">
        <h4>Wat zijn VR environments?</h4>
        <p>Virtual Reality (VR) is het gebruik van computertechnologie om een gesimuleerde omgeving te creëren. In tegenstelling tot traditionele gebruikersinterfaces plaatst VR de gebruiker in een ervaring. In plaats van een scherm voor zich te bekijken, worden gebruikers ondergedompeld en kunnen ze communiceren met 3D-werelden. Door zoveel mogelijk zintuigen te simuleren, zoals visie, horen, aanraken, zelfs ruiken, wordt de computer getransformeerd in een poortwachter voor deze kunstmatige wereld. De enige limiet aan bijna-echte VR-ervaringen is de beschikbaarheid van content en goedkope rekenkracht.
        <br></br>Bron: <a href="https://www.marxentlabs.com/what-is-virtual-reality/">https://www.marxentlabs.com/what-is-virtual-reality/</a></p>
      </div>
      <img src="images/imageVRenvironments.png"></img>
    </div>

    <div id="uitlegOpdrachten">
      <p>Tijdens de workshop over VR environments heb ik aan verschillende dingen gewerkt. Allereerst ben ik "Spatial Augmented Reality" gaan ontdekken, door met de Projecting Mapping Software interactieve projecties te maken. Vervolgens ben ik met "Unreal Enigne" aan de slag gegaan. Dit is een ontwikkelomgeving waarin je virtuele werelden kunt creëren. Het is momenteel de beste game-engine en is gebruikt om veel AAA-spellen en -simulaties te maken.
      Tijdens de workshop heb ik door middel van twee opdrachten een eenvoudige, interactieve virtuele omgeving gecreëerd. Al deze onderdelen zijn hieronder weergegeven en geïlustreerd met screenshots en video's.</p>
    </div>

    <section id="content" class="grid-containerContent">

        <div class="opdracht flex-item">
          <hr>
          <h3>Opdracht 1: Spatial Augmented Reality</h3>
          <p>Spatial Augmented Reality (SAR - ook bekend als Projection Mapping) maakt gebruik van alledaagse videoprojectoren, maar in plaats van te projecteren op een flatscreen (bijvoorbeeld om een PowerPoint weer te geven), wordt licht op elk oppervlak in kaart gebracht, waardoor gewone objecten van elke 3D-vorm in interactieve displays worden omgezet. Projection Mapping is dus kortgezegd "de weergave van een afbeelding op een vlak dat niet plat is of een vlak dat niet wit is".</p>
          <p>Voor deze opdracht moest één iemand per groepje het programma MadMapper downloaden, zodat we via daar de projecties konden maken. De bedoeling was dat we tijdens deze workshop dit programma zouden gaan ontdekken en uiteindelijk een interactieve projectie ermee zouden maken.</p>

          <div id="voorbeeld1">
            <p>Allereerst zijn we het gebruiken van afbeeldingen en het goed plaatsen uit gaan proberen. Hier hadden we een sixpack op iemand geprojecteerd.</p>
            <img src="images/spatialAugmentedRealityVoorbeeld1.png"></img>
          </div>

          <div id="voorbeeld2">
            <video controls>
              <source src="images/videoSpatialAugmentedReality1.mp4" type="video/mp4">
            </video>
            <p>Vervolgens gingen we werken met audio in combinatie met het interactief maken van de projectie. We hadden een afbeelding van een bij geplaats als basis. Daarbij hadden we nog een foto van een bij erin gezet, maar die foto reageerd op geluid. Zodra er geluid geproduceerd wordt, komt de bij tevoorschijn vanuit de andere bij. Door middel van lagen stonden ze namelijk achter elkaar. Als er dus veel hoge tonen geconstateerd worden dan blijft de bij langer te voorschijn. Is er geen geluid dan blijft de bij stilstaan en in dit geval zie je hem dan niet. </p>
          </div>

          <div id="voorbeeld3">
            <p>Daarna waren we naar een andere plek verplaatst, omdat we hier beter konden werken met onderdelen waarop we konden projecteren. Hier zijn we aan de slag gegaan met een taart. We hadden twee ronde vormen die we op elkaar konden leggen als taart basis en een wit vlak als achtergrond. Toen hebben we een afbeelding van een taart erop geprojecteerd een een filmpje van kaarsen. Zo leek het op een echte taart met echte kaarsjes. Daarnaast reageerden de kaarsjes ook op geluid; zo konden we het beeld schetsen dat als je de kaarsjes uitblaast (en dus het geluid van blazen gebruikt) de kaarsjes ook echt uitgaan.</p>
            <video controls>
              <source src="images/videoSpatialAugmentedReality2.mp4" type="video/mp4">
            </video>
          </div>

          <div id="voorbeeld4">
            <video controls>
              <source src="images/videoSpatialAugmentedReality3.mp4" type="video/mp4">
            </video>
            <p>Tot slot wilden we nog een andere projectie op een ander vlak proberen. Dit vlak had een soort bal in het midden, waarop we een discobal hebben geprojecteerd. Daaromheen had het allemaal driehoeken. In die driehoeken kan je precies een afbeelding of filmpje projecteren. Dat was dan ook de bedoeling hierbij. We hebben dit helaas niet volledig af kunnen ronden.</p>
          </div>

          <p id="note">*De foto's en video's die weergegeven worden zijn door mij en mijn groepje gemaakt. We hebben de foto's met elkaar uitgewisseld, omdat we samen aan de opdracht hebben gewerkt en zodat iedereen deze foto's op zijn/haar portfolio kon plaatsen.

        </div>

        <div class="opdracht2VRenvironments flex-item">
          <hr>
          <h3>Opdracht 2 (deel 1): Unreal Enginge - Banana Turntable</h3>
          <p>Voor deze opdracht moest ik van te voren de enginge installeren want dat kost aardig wat tijd. Tijdens de workshop ging ik bij het eerste deel van de opdracht Unreal Enginge aan de slag met het navigeren door de interface en het maken van mijn eerste game-object. Hierbij was het de bedoeling dat je een gele banaan kreeg die ronddraait, zodat we die weer bij het tweede deel konden gebruiken. Hiervoor heb ik meerdere stappen doorlopen. Hieronder worden wat screenshots van deze stappen getoond en een filmpje van het eindresultaat.</p>
          <div id="imagesBananaTurntable">
            <img src="images/unrealEngine1.png"></img>
            <img src="images/unrealEngine2.png"></img>
            <img src="images/unrealEngine3.png"></img>
            <img src="images/unrealEngine4.png"></img>
          </div>
          <div id="uitlegBananaTurntable">
            <p>Allereerst heb ik een nieuw project aangemaakt, met een blank template. Toen moest ik een model van een banaan downloaden en importeren. Deze banaan ging ik daarna in de viewport zetten, waarbij ik ook gelijk leerde hoe ik een object moet bewegen (W), draaien (E) en schalen (R). Om de banaan de gele kleur te geven moest ik een materiaal toevoegen. Hiervoor klikte ik op "Add New" en dan op "Material". Als ik dan op Banana_Material dubbel klikte opende zich een nieuw scherm waarrin ik het materiaal kon aanpassen (zie screenshot 2). Vervolgens moest ik "nodes" en "textures" toe gaan voegen. Hierbij kon ik gebruik maken van "Banana_Texture". De texture node en material node moesten verbonden worden via de output en input ervan. Nu kon je zien dat de bal (het voorbeeld) al geel was! Nu moest de kleur dus nog op de banaan gebracht worden, wat in de content browsers bij de detail panel in de editor geselecteerd kon worden. Om de banaan nu nog draaiende te krijgen moest ik blueprints gebruiken. Dit deed ik weer door bij "Add New" nu "Blueprint Class" aan te klikken en dan voor "Actor" te kiezen. Als ik op Banana_Blueprint dubbel klikte opende zich een nieuw scherm met de editor voor deze blueprint. Hier moest ik een cylinder (waar de banaan op komt) en static mesh (wat de banaan mesh gaat tonen) toe gaan voegen. De cylinder moest korter worden gemaakt d.m.v. de (R) scale manipulator. Als laatste moest ik nu nog blueprint nodes toe gaan voegen in the Event Graph tab. Hierbij werden de output van de event trick en e default scene root verbonden met de input van AddLocalLocation, waarbij ook nog de Z van de delta rotation input in 1.0 veranderd moest worden. Door op Compile te drukken werd nu alles toegevoegd! In de viewport in de main editor moest ik alleen nog de banaan verwijderen en de nieuwe blueprint erin te zetten. Door op play te drukken kon ik hem nu zien draaien, zoals ook op mijn filmpje te zien is!!  </p>
          </div>
          <video controls>
            <source src="images/videoUnrealEngine1.mp4" type="video/mp4">
          </video>
        </div>

        <div class="opdracht3VRenvironments flex-item">
          <hr>
          <h3>Opdracht 2 (deel 2): Unreal Enginge - Banana Collector</h3>
          <p>Bij deze opdracht ging ik verder met het ontdekken van het programma Unreal Engine. Ik had bij opdracht 1 (zie hierboven) al een start gemaakt en het eindresultaat daarvan kwam later in deze opdracht ook weer naar voren. De bedoeling van deze opdracht was om meer te leren over blueprints en om hiermee een spelerpersonage te maken, inputs in te stellen en een item te laten verdwijnen wanneer de speler het aanraakt. Hiervoor heb ik weer meerdere stappen doorlopen. Hieronder worden dan ook weer screenshots van de stappen en een filmpje van het eindresultaat getoond.</p>
          <div id="imagesBananaCollector">
            <img src="images/unrealEngine5.png"></img>
            <img src="images/unrealEngine6.png"></img>
            <img src="images/unrealEngine7.png"></img>
            <img src="images/unrealEngine8.png"></img>
            <img src="images/unrealEngine9.png"></img>
            <img src="images/unrealEngine10.png"></img>
            <img src="images/unrealEngine11.png"></img>
            <img src="images/unrealEngine12.png"></img>
            <img src="images/unrealEngine13.png"></img>
          </div>
          <div id="uitlegBananaCollector">
            <p>Allereerst moest ik "the starter project" downloaden en het project BananaCollector.unproject openen. Dan kreeg je het beeld te zien wat op de eerste afbeelding hiernaast te zien is. Vervolgens ging ik een camera toevoegen. Hiervoor ging ik naar de blueprint editor van BP_Player en drukte ik op Add Component om daar camera te selecteren. Deze camera moest verplaatst worden naar (-1100, 0, 2000) en geroteerd tot -60 graden op de Y-as (zie afbeelding 2). Een rood blokje moest uiteindelijk de "speler" gaan voorstellen, dus om dat te maken moest ik een Static Mesh bij Add Component toevoegen. Daarna heb ik bij de details nog SM_Cube voor de Static Mesh geselecteerd. Nu kon ik (na op compile gedrukt te hebben) terug naar de hoofd editor. Nu ging ik een gamemode toevoegen; een gamemode is een klasse die bepaalt hoe een speler het spel begint. Dus door Add New, Blueprint Class en Game Mode Base te selecteren creëerde ik dit. Nu moest ik alleen nog de pion klasse aan te geven, door bij Default Pawn Class BP_Player te selecteren. In de hoofd editor ging ik nu aangeven dat ik de game modus GM_Tutorial (die ik net had aangemaakt) wilde gebruikende, dus via World Settings veranderde ik dit. Nu kon ik de Player Start in het spel gaan plaatsen. Hiervoor zocht ik naar "Player Start" en die sleepte ik in het scherm, waarna je het beeld van afbeelding 4 van hiernaast te zien kreeg. Nu moest een sleutel aan een actie gaan toewijzen, wat "key binding" wordt genoemd. Ik ging naar Edit, Project Settings en dan naar Input onder de Engine sectie. Bij de bindings sectie kon ik hier mijn inputs gaan toevoegen. Om te zorgen dat de player uiteindelijk kan bewegen heb ik MoveForward (voor naar voren en naar achter) en MoveRight (voor naar links en naar rechts) toegevoegd. Deze acties heb ik toegewijsd aan vier toetsen: W, A, S en D, waarbij de S en A nog een scale van -1 kregen (zie ook afbeelding 5). Nu moest ik er nog voor gaan zorgen dat de pion echt zou kunnen gaan bewegen! Hiervoor opende ik de BP_Player in de blueprints editor. Om aan te geven hoe snel de pion zou bewegen moest ik variabelen toevoegen. Hierbij gebruikte ik MaxSpeed, Float en veranderde ik de Default Value naar 10. Vervolgens ben ik deze onderdelen in the Event Graph gaan zetten en gaan verbinden met de float * float node, de Get Forward Vector node en de Add Movement Input node. Hetzelfde proces voerde ik voor MoveRight uit. Deze verbindingen zijn in afbeelding 6 te zien. Om de pion nog echt te laten bewegen moest ik nog de Event Trick gebruiken en verbinden aan de Consume Movement Input Vector node en de AddActorLocalOffset node. Na op compile gedrukt te hebben kon ik nu de pion (het rode blokje) bewegen met de toetsen!! Alleen moest ik nog de frame snelheid veranderen door een vector * float node toe te voegen en die te verbinden met de delta seconds, de return value en de delta location. Ook moest de MaxSpeed veranderd worden naar 600. Nu was mijn game "onafhankelijk van de framesnelheid". Omdat de pion overal doorheen ging, ging ik tot slot meer leren over Collisions. Om een collision mesh te gebruiken moest de StaticMesh veranderd worden:de StaticMesh moest naar de DefaultSceneRoot gesleept worden, zodat de StaticMesh de nieuwe "root" werd. Ook moest ik bij de AddActorLocalOffset nog de "Sweep" input aanvinken. Het allerlaatste wat nu nog moest gebeuren was het zorgen dat een item verdwijnt wanneer de speler het aanraakt. Hiervoor ging ik de BP_Banana uit opdracht 1 gebruiken! In de StaticMesh component van BP_Banana ging ik naar de Collision sectie bij de details. Om de instellingen hierbij te kunnen veranderen moest ik "Custom" selecteren. Nu kon ik de "overlap" box bij WorldDynamic aanvinken. Om hiermee om te kunnen gaan moest ik een Event toevoegen bij de StaticMesh: de OnComponentBeginOverlap. Door een DestroyActor node hieraan te linken zal het item dus in het spel verdwijnen op de manier dat we het wilden. In de viewport van de Blueprints map heb ik nu de BP_Banana meerdere keren geplaatst en nu was mijn game af!! Door op play te drukken kon ik met de aangegeven toetsen navigeren door het spel en de banaantjes weghalen. Zie het filmpje hieronder voor hoe dit werkte en er uiteindelijk uitzag.</p>
          </div>
          <video controls>
            <source src="images/videoUnrealEngine2.mp4" type="video/mp4">
          </video>
        </div>

    </section>

    <section class="grid-container footer">

      <div class="grid-item naam box1">
        <p class="flex-item flex-itemNaam">	&copy; Femke van der Burg </p>
        <p class="flex-item beroep">	Interaction &amp; UX Designer </p>
        <p class="flex-item website"> <a href="www.femkevanderburg.nl">www.femkevanderburg.nl</a></p>
      </div>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script type="text/javascript" src="scripts/main.js"></script>

  </body>
</html>
